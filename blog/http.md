**File Name** http.md  
**Description**  《HTTP权威指南》读书笔记   
**Author** LiCunchang (printf@live.com)  
**Version** 1.0.20131001  

------

## 1 Overview of HTTP

Internet 上有数千种不同的数据类型，HTTP 给每种对象都标记了 MIME(Multipurpose Internet Mail Extension, 多用途因特网邮件扩展)标签，最初 MIME 是为了解决在不同的电子邮件系统之间搬移报文时存在的问题，MIME 在电子邮件系统中工作的非常好，因此HTTP 也采纳了它。当 WEB 浏览器从服务器中取回一个对象时，会去查看相关的 MIME 类型，看看它是否知道应该如何处理这个对象。

HTTP 是个应用层协议，HTTP 无需操心网络通信的具体细节，他把联网的细节都交给了通用、可靠的因特网传输协议 TCP/IP。TCP 提供了：

* 无差错的数据传输
* 按序传输（数据总是会按照发送的顺序到达）
* 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

## 2 URLs and Resources

    <scheme>://<user>:<password>@<host>:<port>/<path>;<params>?<query>#<frag>

几乎没有哪个 URL 中包含了所有这些组件。URL 最重要的 3 个部分是 scheme、host、path 。

相对 URL 只是 URL 的片段或一小部分，处理相对 URL 需要找到基础 URL，基础 URL 可以使用 `<base>` 标签来指定，或者将所属资源的 URL 作为基础。

## 3 HTTP Messages

HTTP 报文是简单的格式化数据块。每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应，它们由三个部分组成：对报文进行描述的起始行（start line）、包含属性的首部（header）块、以及可选的、包含数据的主体（body）部分。

>   * Slowloris 攻击
>   * HTTP POST DOS

    start-line \r\n
    headers \r\n\r\n
    body

**注意**即使没有 headers 部分，也应该以一个空行结束。

状态码位于响应的起始行中，通过三位数字代码对不同的状态进行分类。同时，每一个状态码对应一个 reason phrase 原因短语，原因短语是状态码的可读版本，HTTP 规范并没有提供任何硬性规定要求原因短语以何种形式出现。

每个 HTTP 首部都有一种简单的语法：名字后面跟着冒号（:），然后跟上可选的空格，再跟上字段值，最后是一个CRLF，有的时候需要将很长的 header 分成多行提高可读性，那么多出来的每行前面至少要有一个空格或者制表符(tab)。

    HTTP/1.0 200 OK
    Server: Test Server
        Version 1.0

在上面的例子中，相应报文包含了一个 Server 首部，其值被划分成了多个延续行，该首部的完整值为 Test Server Version 1.0。

HEAD 和 GET 方法都被认为是安全的方法，这就意味着使用 GET 或 HEAD 方法的 HTTP 请求都不会产生什么动作，实际上，安全方法并不一定是什么动作都不执行，因为这是由开发者决定的。HEAD 方法与 GET 方法的行为很类似，但服务器在响应中只返回首部，不会返回实体的主体部分。这就允许客户端在未获取资源的情况下，对资源的首部进行检查。服务器开发者必须确保返回的首部与 GET 请求所返回的首部完全相同。

客户端发起一个请求时，这个请求可能要穿过防火墙、代理、网关或其他一些应用程序，每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子。TRACE 方法主要用于诊断，也就是说，用于验证请求是否如愿穿过了请求/响应链。他也是一种很好的工具，可以用来查看代理和其他应用程序对用户请求所产生的效果。TRACE 也有缺点，它假定中间应用程序对各种不同类型请求（GET\POST等）的处理是相同的，很多 HTTP 应用程序会根据方法的不同做出不同的事情。TRACE 并不能提供区分这些方法的机制，通常中间应用程序会自行决定对 TRACE 请求的处理方式。TRACE 请求中不能带有实体的主体部分，TRACE 响应的实体主体部分包含了响应服务器收到的请求的精确副本。

状态码中100~199表示信息性状态码，其中100 continue说明收到了请求的初始部分，请客户端继续。他的目的是对这样的情况进行优化：HTTP客户端应用程序有一个实体的主体部分要发送给服务器，但是希望在发送之前查看一下服务器是否会接受这个实体，那么客户端就要发送一个携带了值为100 Continue的Expect请求首部，如果客户端没有发送实体，就不应该发送一个100 Continue Expect首部，因为这样会使服务器误以为客户端要发送一个实体。这是一种优化，客户端应用程序只有在避免向服务器发送一个服务器无法处理或使用的大实体时，才应该使用100 Continue。但是客户端在超过一定时间没有收到服务器的100响应之后应该直接将实体发送出去，同时，如果服务器端已经收到了实体部分，那么就不必要再发送100状态。
//TODO page 63 章节 4.7.4

状态码302、303、307之间存在一些交叉，有一些细微的差别，大部分的差别都源于HTTP/1.0和HTTP1.1应用程序对这些状态码处理方式的不同。当HTTP/1.0客户端发起一个POST请求，并在响应中收到302重定向状态码时，他会接受location首部的重定向URL，并向那个URL发起一个GET请求，而不是像原始请求那样发起POST请求，HTTP/1.0服务器希望HTTP/1.0客户端这么做——如果HTTP/1.0服务器收到来自HTTP/1.0客户端的POST请求之后发送了302状态码，服务器就期望客户端能够接受重定向URL并向重定向的URL发送一个GET请求，问题处在HTTP/1.1,HTTP/1.1规范使用303状态码来实现同样的行为（服务器发送303状态码来重定向客户端的POST请求，在他后面跟上一个GET请求）为了避开这个问题，HTTP/1.1指出，对于HTTP/1.1服务器，用307状态码取代302状态码来进行临时重定向，这样服务器就可以将302状态码保留起来，为HTTP/1.0客户端使用了。
//TODO php 重定向

405状态码表示发起的请求中带有所请求的URL不支持的方法时使用，同时应该在响应中包含allow首部。

## 4 连接管理

HTTP 通信是由TCP/IP承载的，它为HTTP提供了一条可靠的比特传输通道，从TCP连接一端填入的字节会从另一端以原有的顺序、正确的传送出来。

TCP 的数据是通过名为 IP 分组（或IP 数据报）的小数据块发送的。从一个 IP 地址发送到另一个 IP 地址的，每个 IP 分组中都包括：

* 一个IP 分组首部（通常为20字节）
* 一个 TCP 段首部（通常为20字节）
* 一个 TCP 数据块（0个或多个字节）

IP 首部包含了源和目的 IP 地址、长度和其他一些标记。TCP 段的首部包含了 TCP 端口号、TCP 控制标识，以及用于数据排序和完整性检查的一些数字值。

每一个 TCP 连接由四个值来识别：源IP地址、源端口号、目的IP地址、目的端口号。这四个值一起唯一的定义了一条连接。

常见的 TCP 相关时延，对 HTTP 产生影响的因素有

* TCP 连接建立握手
* TCP 慢启动拥塞控制
* 数据聚集的 Nagle 算法
* 用于捎带确认的 TCP 延迟确认算法
* TIME_WAIT 时延和端口耗尽

每个 TCP 都有一个序列号和数据完整性校验和，每个段的接受者收到完好的段时，都会向发送者回送小的确认分组，如果发送者没有在指定的窗口时间内收到确认信息，发送者就认为分组已被破坏或损毁，并重发数据，由于确认报文很小，所以 TCP 允许在发往相同方向的输出数据分组中对其进行“捎带”，TCP 将返回的确认信息与输出的数据分组结合在一起，可以更有效地利用网络。为了增加确认报文找到通向传输数据分组的可能性，很多TCP栈都实现了一种“延迟确认”算法，该算法会在一个特定的窗口时间（通常是 100~ 200毫秒）内将输出确认放在缓冲区中，以寻找能够捎带他的输出数据分组。如果在那个时间段内没有输出数据分组，就将确认信息放在单独的分组中传送。但是 HTTP 具有双峰特征的请求：应答行为降低了捎带信息的可能。当希望有相反方向回传分组的时候，偏偏没有那么多。通常，延迟算法会引入相当大的时延。

TCP 数据传输的性能还取决于 TCP 连接的使用期（age）。TCP 连接会随着时间进行自我“调谐”，起初会限制连接的最大速度，如果数据成功传输，会随着时间的退役提高传输的速度，这种调谐被成为 TCP 满启动（slow start），用于防止因特网的突然过载和拥塞。

关于 TIME_WAIT 端口耗尽，当某个 TCP 端点关闭 TCP 连接是，会在内存中维护一个小的控制块，用来记录最近所关闭连接的 IP 地址和端口号，这类信息只会维持一小段时间，通常是所估计的最大分段使用期的两倍（2MSL）左右，以确保在这段时间内不会创建具有相同地址和端口号的新连接，实际上，这个算法可以防止在两分钟内创建、关闭并重新创建两个具有相同IP地址和端口号的连接。

串行的 HTTP 事务因为会对时延进行叠加，所以可能导致加载速度缓慢，现在有几种方法可以提高 HTTP的连接性能

* 并行连接。通过多条 TCP 连接发起并发的 HTTP 请求
* 持久连接。重用 TCP 连接，以消除连接及关闭时延
* 管道化连接。通过共享的 TCP 连接发起并发的 HTTP 请求
* 复用的连接。交替传送请求和响应报文（试验阶段）

并行连接使用多条连接并行的执行多个 HTTP 事务，这样时延可以重叠起来，有效的降低总体时延，但是并行连接的速度并不一定更快，如果客户端的网络带宽不足时，这样的情况下性能提升就很小甚至没有提升。同时大量连接的打开会消耗很多内存资源。并行连接有以下缺点

* 每个事务都打开/关闭一条新的连接，会耗费时间和带宽
* 由于 TCP 慢启动特性的存在，每条新连接的性能都会有所降低
* 可打开的并行连接数量实际上是有限的

持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态，而且减少了打开链接的潜在数量，但是管理持久连接要特别小心，不然就会积累出大量的空闲连接，好肥本地以及远程客户端和服务器上资源。

持久连接与并行连接配合使用可能是最高效的方式。持久连接有两种方式：比较老的 HTTP/1.0 + “keep-alive” 连接，以及现代的 HTTP/1.1 “persistent” 连接

为了避免出现哑代理的情况，现代的代理服务器都绝不能转发 connection 首部和名字出现在 connection 值中的首部，因此如果一个代理收到了一个connection: Keep-alive 首部，是不应该转发 connection 首部，或所有名为 keep-alive的首部的。

HTTP/1.1 逐渐停止了对 keep-alive 连接的支持，用一种名为持久连接（persistent connection）的改进型设计取代了他，持久连接的目的与keep-alive 连接的目的相同，但工作机制更优一些。在默认情况下，持久连接是激活的，除非特别指明，否则 http/1.1 假定所有的连接都是持久的，要在事务处理结束之后将连接关闭， HTTP/1.1 应用程序必须向保温中显式的添加一个 connection:close 首部。

## 5 WEB 服务器

## 6 代理

代理的情况下，客户端发送完整的URI，同时发送 Proxy-connection 首部，但是，同样的，Proxy-connection 没有解决哑代理的问题。

HTTP 规范禁止一搬的拦截代理在转发 URI 时重写其绝对路径部分，唯一的例外时可以用“/”来取代空路径。

现在将web请求从客户端传送到服务器的路径上经过两个或者多个代理是很常见的，随着代理的逐渐流行，我们要能够追踪经过代理的报文流，以检测各种问题，其重要性就跟追踪经过不同交换机和路由器传输的IP分组一样。`Via` 首部字段列出了与报文途径的每个中间结点（代理或网关）有关的信息，报文没经过一个节点，都必须将这个中间节点添加到via列表的末尾。

代理服务器可以在转发报文时对其进行修改，可以添加、修改或者删除首部，也可以将主体部分转换成不同的格式，为了便于对代理网络进行诊断，我们可以通过 HTTP\1.1 的 TRACE 方法追踪经代理链传输的请求报文，观察报文经过了哪些代理，以及每个代理是如何对请求报文进行修改的。MAX-Forwards 首部包含了一个整数，用来说明这条请求报文还可以被转发的次数，如果 MAX-Forwards的值为零，那么即使接收者不是原始服务器，他也必须将 TRACE 报文回送给客户端，而不应该继续转发。

代理可以作为访问控制设备使用。具体407 状态码  Proxy-Authenticate 首部。

代理服务器必须对不认识的首部字段进行转发，而且必须维持同名首部字段的相对顺序。如果代理不熟悉某个方法，那么只要可能，就应高尝试着将报文转发到下一跳节点上去。

## 7 缓存

原始服务器的内容可能会发生变化，缓存要不时对其进行检测，看看他们保存的副本是否仍是服务器上最新的副本，这些“新鲜度验证”被成为 HTTP 再验证revalidation。

缓存不应该调整 Date 首部，Date 首部表示的是原始服务器最初产生这个对象的日期。

HTTP 有一些简单的机制可以在不要求服务器记住有哪些缓存拥有其文本副本的情况下，保持已缓存的数据与服务器数据之间充分一致，HTTP 将这些简单的机制称为文档过期和服务器再验证。

通过 Cache-Control 首部和 Expires 首部，HTTP 让原始服务器向每个文档附加了一个“过期时间”。服务器用HTTP/1.0+的Expires 首部或者 HTTP/1.1 的Cache-Control:max-age 响应首部来指定过期日期，这两者本质上做的事情是一样的，但是由于 Cache-Control 首部使用的是相对时间而不是绝对日期，所以我们更倾向于使用比较新的 Cache-Control 首部，绝对日期依赖于计算机时钟的正确设置。

	HTTP/1.1 304 Not Modified
	Server: Microsoft-IIS/6.0
	Date: Sat, 05 Oct 2013 15:49:36 GMT
	Last-Modified: Mon, 16 Sep 2013 10:09:59 GMT
	Connection: keep-alive
	Expires: Mon, 04 Nov 2013 15:49:36 GMT
	Cache-Control: max-age=2592000
	Cache-Control: no-cache
	Cache-Control: private

Cache-Control: max-age=2592000 定义了文档的最大使用期（单位：秒），`Expires: Mon, 04 Nov 2013 15:49:36 GMT` 指定了一个绝对的过期日期。

HTTP 定义了5个条件请求首部，对缓存再验证来说最有用的2个首部是`If-Modified-Since` 和 `If-None-Match` 所有的条件首部都以前缀 `If-` 开头。`If-Modified-Since: <cached last-modified date>`，有些WEB 服务器并没有将 If-Modified_since 作为真正的日期来进行比对，相反，他们在 IMS 日期和最后修改日期之间进行了字符串匹配。将最后修改日期作为某种序列号使用时，这种替代语义能够很好的识别出缓存是否过期，但这会妨碍客户端将 If-Modified-Since 首部用于真正基于时间的一些目的。

某些情况下仅使用最后修改日期进行再验证是不够的。有些文档可能会被周期性的重写，但实际包含的数据常常是一样的，还有其他的一些情况，为了解决这些问题，HTTP 允许用户对被称为实体标签（ETag）的版本标识符进行比较，实体标签是附加到文档上的任意标签，他们可能包含了文档的序列号或者版本号，或者是文档内容的校验和及其他指纹信息。

当发布者对文档进行修改时，可以修改文档的实体标签来说明这个新的版本，这样如果实体标签被修改了，缓存就可以用 If-None_match 条件首部来GET文档的新副本了。

有时候服务器希望在对文档进行一些非实质性或不重要的修改时，不要使所有的已缓存副本都失效，HTTP/1.1支持弱验证器，如果之对内容进行了少量修改，就允许服务器生命那是“足够好”的等价体。弱验证器会用前缀“W/”来标识弱验证器。

	ETag: W/"v2.6"
	If-None-Match: W/"v2.6"

如果服务器回送了一个实体标签，HTTP/1.1 就必须使用实体标签验证器，如果服务器只回送了一个 Last-Modified 值，客户端就可以使用 If-Modified-Since 验证，如果实体标签和最后修改日期都提供了，客户端就应该使用这两种再验证方案，这样 HTTP/1.0 和 HTTP/1.1 都能正确响应了，除非 HTTP/1.1 原始服务器无法生成实体标签验证器，否则就应该发送一个出去，如果使用弱实体标签有优势的话，发送的可能就是个弱实体标签，而不是强实体标签，而且最好同时发送一个最近修改值。如果HTTP/1.1缓存或服务器收到的请求包含两者，那么只有这两个条件都满足时，才能返回304 Not Modified 响应。

服务器可以通过HTTP定义的几种方式来制定文档过期之间可以将其缓存多长时间，按照优先级递减的顺序，服务器可以

* 附加一个 Cache-Control: no-store
* 附加一个 Cache-Control: no-cache 
* 附加一个 Cache-Control: must-revalidate
* 附加一个 Cache-Control: max-age
* 附加一个 Expire 日期首部到响应中去
* 不附加过期信息，让缓存确定自己的过期日期。








































































































