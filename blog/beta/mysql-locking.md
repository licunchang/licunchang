MySQL 管理表锁的机制为：

1. MySQL 服务器使用内部锁管理多线程之间的表争用问题。这种类型的锁是内部锁，因为这种类型的锁是服务器管理的，并且没有调用任何其他程序
2.  其他锁发生在服务器还？？？

## 1 internal locking methods

MySQL 使用行级锁(row-level locking)来解决 InnoDB 表的多会话同时写，同时 MySQL 为 MyISAM、MEMORY、MERGE表使用表级锁(table-level locking)，只能在同一时间允许一个会话更新表。

行级锁的优点

* 更少的锁冲突
* 更少的变更回滚
* 可能早很长的时间内锁定一行

行级锁的缺点

* 比表级锁需要更多的内存
* 当更新表的大部分的时候时需要很多的锁，所以比表级锁要慢
* 如果你需要经常扫描表或者经常在表的大部分上做group by 操作的时候比其他锁要慢

MySQL 写表锁按照下面的规则

1. 如果表没有锁，那么给一个写表锁(write lock)
2. 不符合上面的需求，把锁放入写锁的队列中

MySQL 读表锁按照下面的规则

1. 如果表没有写锁，给一个读锁
2. 否则，将加锁请求放入到读锁队列中

表更新操作比其他表操作有更高的优先级。因此，当一个锁被释放，写锁队列的请求就马上可用，然后才是读锁队列的请求，这导致了即使有一个很着急的select请求，也必须等到所有的update执行完毕

Table_locks_immediate   表锁能立即获得的次数
Table_locks_waited      表锁等待的次数

MyISAM 引擎支持并发插入，…… 
如果在数据文件中没有空闲的 blocks 的时候，行总是被插入到数据文件的末尾
在这种情况下，myisam 表 可以在不使用锁的情况下并发的执行 insert select 操作，也就是说，你可以在myisam表中插入行当其他客户端正在读的时候。数据文件中的间隙产生于删除数据或者更新数据之后，如果数据文件中有空闲的blocks 并发插入就不可用了，但是当这些空闲的地方被新数据填充的时候，并发插入又可以继续，这个行为可以被变量 concurrent_insert 设置。
















